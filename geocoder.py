# -*- coding: utf-8 -*-
"""geocoder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tsAIp7gNFH2p_I5FSr5kfRI7mQdJ9flp
"""

# 1

from opencage.geocoder import OpenCageGeocode
import pandas as pd
import time
import plotly.express as px

# 2

key = 'f9f26f6a1fad459b958f47e98cc46eb6'
# get api key from:  https://opencagedata.com

geocoder = OpenCageGeocode(key)

"""Example snippet to invoke api \
query = 'place name'
results = geocoder.geocode(query)

pprint(results)"""

# 3 only in case we have previous output saved
# action = input("Are you running this script for the first time(yes or no)?")

# fill your own data path if you have your own saved files.
def tweets_load():
    # loads stored csv file into DataFrame.
    data_file = pd.read_csv(r"c: \\Users\\ADMIN\
                            OneDrive\\Courses V Projects\\Idea Projects\
                            Twitter Data Retrieval\\Project files\
                            temple_tweets.csv")
    return data_file


def coords_load():
    coord_file = pd.read_csv(r"c: \Users\ADMIN\OneDrive\
                             Courses V Projects\Idea Projects\
                             Twitter Data Retrieval\Project files\
                             temple_cords.csv")
    return coord_file


# 4(when a new csv file is being used for the first time)
main_tweets = tweets_load()


# Extracting and copying relevant data for geocoding into another panda
loc_data = main_tweets[['user_location']].copy()

list_places = loc_data['user_location'].unique().tolist()

# print((list_places)), #.unique() stores only unique values.


# 2500 calls per day limit as of 6th September 2020
lat = {}
lon = {}
count = 0

# empty dictionary to store lat , long
# next time we call api REMEMBER to store lat and long in two different
# dictionaries.
for place in list_places:
    try:
        if isinstance(place, str) is True:
            query = place
            results = geocoder.geocode(query, no_annotations='1')
            lat[query] = results[0]['geometry']['lat']
            lon[query] = results[0]['geometry']['lng']
            count = count + 1
            if count % 10 == 0:
                time.sleep(1)
        else:
            lat[query] = 0
            lon[query] = 0
    except Exception:
        lat[query] = 0
        lon[query] = 0

# print('Length of locations:', len(lat), len(lon))

# creating a duplicate column that we will overwrite next.
loc_data['latitude'] = loc_data['user_location']
loc_data['longitude'] = loc_data['user_location']
print(loc_data.head())

# Using Pandas .map() to overwrite values in colum lat long
# with coreesponding dict values.
loc_data['latitude'] = loc_data['latitude'].map(lat)
loc_data['longitude'] = loc_data['longitude'].map(lon)


# saving file for later use
loc_data.to_csv('temple_cords.csv')

# loading co-ordinate file (loc_data)
cords_data = coords_load()
temple_tweets = tweets_load()

# Creating main_data panda for mapping
new_data = temple_tweets[['Hash_text', 'user_screen_name']].copy()
main_data = pd.concat([cords_data, new_data], axis=1)

main_data.user_location.fillna('Inaccurate', inplace=True)
# fill NaN values with above string and below we convert co-ords to float
main_data['latitude'] = main_data.latitude.astype('float64')
main_data['longitude'] = main_data.longitude.astype('float64')

# give the parameters for mapping.
figure = px.scatter_mapbox(main_data, lat="latitude", lon="longitude",
                           color="user_location",
                           hover_name='user_screen_name',
                           hover_data=['Hash_text'], zoom=12)

figure.update_layout(mapbox_style="open-street-map")
figure.show()
